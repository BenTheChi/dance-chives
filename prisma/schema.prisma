datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id               String          @id @default(cuid())
  name             String?
  email            String          @unique
  emailVerified    DateTime? // Keep for NextAuth compatibility
  accountVerified  DateTime? // User completed registration after OAuth
  image            String?
  accounts         Account[]
  sessions         Session[]
  // Optional for WebAuthn support
  Authenticator    Authenticator[]
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  auth             Int?

  events          Event[]
  sentInvitations Invitation[]

  // Request relationships
  sentTaggingRequests           TaggingRequest[]         @relation("TaggingRequestSender")
  receivedTaggingRequests       TaggingRequest[]         @relation("TaggingRequestTarget")
  sentTeamMemberRequests        TeamMemberRequest[]      @relation("TeamMemberRequestSender")
  sentAuthLevelChangeRequests   AuthLevelChangeRequest[] @relation("AuthLevelChangeRequestSender")
  targetAuthLevelChangeRequests AuthLevelChangeRequest[] @relation("AuthLevelChangeRequestTarget")

  // Notification relationships
  notifications Notification[]

  // Request approvals
  requestApprovals RequestApproval[]
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

// Optional for WebAuthn support
model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}

model Event {
  id      String  @id @default(cuid())
  eventId String  @unique
  userId  String
  creator Boolean @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Invitation {
  id        String    @id @default(cuid())
  email     String
  authLevel Int
  invitedBy String
  token     String    @unique
  expires   DateTime
  used      Boolean   @default(false)
  usedAt    DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  inviter User @relation(fields: [invitedBy], references: [id], onDelete: Cascade)

  @@index([email])
  @@index([token])
}

// Request Models

enum RequestStatus {
  PENDING
  APPROVED
  DENIED
  CANCELLED
}

model TaggingRequest {
  id           String        @id @default(cuid())
  eventId      String // Event ID from Neo4j
  videoId      String? // Optional video ID from Neo4j
  senderId     String // User requesting the tag
  targetUserId String // User being tagged
  role         String? // Optional role/tag type
  status       RequestStatus @default(PENDING)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  sender     User @relation("TaggingRequestSender", fields: [senderId], references: [id], onDelete: Cascade)
  targetUser User @relation("TaggingRequestTarget", fields: [targetUserId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@index([senderId])
  @@index([targetUserId])
  @@index([status])
}

model TeamMemberRequest {
  id        String        @id @default(cuid())
  eventId   String // Event ID from Neo4j (stored as string reference)
  senderId  String // User requesting to be a team member
  status    RequestStatus @default(PENDING)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  sender User @relation("TeamMemberRequestSender", fields: [senderId], references: [id], onDelete: Cascade)
  // Note: eventId references Neo4j event, not PostgreSQL Event model

  @@index([eventId])
  @@index([senderId])
  @@index([status])
}

model AuthLevelChangeRequest {
  id             String        @id @default(cuid())
  senderId       String // User requesting the change
  targetUserId   String // User whose auth level should change
  requestedLevel Int // The requested authorization level
  currentLevel   Int // Current authorization level
  message        String // Mandatory explanation message
  status         RequestStatus @default(PENDING)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  sender     User @relation("AuthLevelChangeRequestSender", fields: [senderId], references: [id], onDelete: Cascade)
  targetUser User @relation("AuthLevelChangeRequestTarget", fields: [targetUserId], references: [id], onDelete: Cascade)

  @@index([senderId])
  @@index([targetUserId])
  @@index([status])
}

model RequestApproval {
  id          String   @id @default(cuid())
  requestType String // "TAGGING" | "TEAM_MEMBER" | "GLOBAL_ACCESS" | "AUTH_LEVEL_CHANGE"
  requestId   String // ID of the specific request (polymorphic reference)
  approverId  String // User who approved/denied
  approved    Boolean // true for approval, false for denial
  message     String? // Optional message from approver
  createdAt   DateTime @default(now())

  approver User @relation(fields: [approverId], references: [id], onDelete: Cascade)

  @@index([requestType, requestId])
  @@index([approverId])
}

model Notification {
  id                 String   @id @default(cuid())
  userId             String // User receiving the notification
  type               String // "INCOMING_REQUEST" | "REQUEST_APPROVED" | "REQUEST_DENIED" | "TEAM_MEMBER_ADDED" | etc.
  title              String
  message            String
  relatedRequestType String? // Type of related request
  relatedRequestId   String? // ID of related request
  read               Boolean  @default(false)
  createdAt          DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([read])
  @@index([createdAt])
}
