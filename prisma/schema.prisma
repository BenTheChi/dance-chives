datasource db {
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id               String          @id @default(cuid())
  name             String?
  email            String          @unique
  emailVerified    DateTime? // Keep for NextAuth compatibility
  accountVerified  DateTime? // User completed registration after OAuth
  image            String?
  accounts         Account[]
  sessions         Session[]
  // Optional for WebAuthn support
  Authenticator    Authenticator[]
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  auth             Int?

  events          Event[]

  // Request relationships
  sentTaggingRequests           TaggingRequest[]         @relation("TaggingRequestSender")
  receivedTaggingRequests       TaggingRequest[]         @relation("TaggingRequestTarget")
  sentTeamMemberRequests        TeamMemberRequest[]      @relation("TeamMemberRequestSender")
  sentAuthLevelChangeRequests   AuthLevelChangeRequest[] @relation("AuthLevelChangeRequestSender")
  targetAuthLevelChangeRequests AuthLevelChangeRequest[] @relation("AuthLevelChangeRequestTarget")

  // Notification relationships
  notifications Notification[]

  // Request approvals
  requestApprovals RequestApproval[]

  // Magic link tokens
  magicLinkTokens MagicLinkToken[]
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

// Optional for WebAuthn support
model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}

model Event {
  id      String  @id @default(cuid())
  eventId String  @unique
  userId  String
  creator Boolean @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Read models (Postgres projections) for fast card + calendar queries.
// These are derived from Neo4j entities and keyed by Neo4j IDs.

enum EventDateKind {
  timed
  allDay
}

model EventCard {
  /// Neo4j Event.id
  eventId String @id

  title     String
  eventType String?

  cityId       String?
  cityName     String?
  region       String?
  countryCode  String?
  eventTimezone String?

  posterUrl String?

  // Denormalized tags for fast card rendering / filtering
  styles String[] @default([])

  /// Primary display date in MM/DD/YYYY (keeps UI stable)
  displayDateLocal String?
  additionalDatesCount Int @default(0)

  /// Event visibility status
  status String @default("visible")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  eventDates    EventDate[]
  sectionCards  SectionCard[]

  @@map("event_cards")
  @@index([cityId])
  @@index([eventType])
  @@index([updatedAt])
  @@index([status])
  @@index([styles], type: Gin)
}

model EventDate {
  id String @id @default(cuid())

  /// Neo4j Event.id
  eventId String
  event   EventCard @relation(fields: [eventId], references: [eventId], onDelete: Cascade)

  kind EventDateKind

  // Always stored as UTC instants for ordering/paging.
  startUtc DateTime @db.Timestamptz(6)
  endUtc   DateTime? @db.Timestamptz(6)

  // For all-day events: authoritative local calendar day in the event timezone.
  localDate DateTime? @db.Date

  createdAt DateTime @default(now())

  @@map("event_dates")
  @@index([eventId, startUtc])
  @@index([startUtc])
}

model SectionCard {
  /// Neo4j Section.id
  sectionId String @id

  /// Neo4j Event.id
  eventId String
  event   EventCard @relation(fields: [eventId], references: [eventId], onDelete: Cascade)

  title       String
  sectionType String?
  posterUrl   String?

  styles String[] @default([])
  totalVideoCount Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("section_cards")
  @@index([eventId])
  @@index([styles], type: Gin)
}

model UserCard {
  /// Neo4j User.id
  userId String @id

  username    String @unique
  displayName String

  imageUrl String?

  cityId   String?
  cityName String?

  styles String[] @default([])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("user_cards")
  @@index([cityId])
  @@index([styles], type: Gin)
  @@index([updatedAt])
}

// Request Models

enum RequestStatus {
  PENDING
  APPROVED
  DENIED
  CANCELLED
}

model TaggingRequest {
  id           String        @id @default(cuid())
  eventId      String? // Event ID from Neo4j
  videoId      String? // Optional video ID from Neo4j
  sectionId    String? // Optional section ID from Neo4j
  senderId     String // User requesting the tag
  targetUserId String // User being tagged
  role         String? // Optional role/tag type (required for videos and sections)
  status       RequestStatus @default(PENDING)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  sender     User @relation("TaggingRequestSender", fields: [senderId], references: [id], onDelete: Cascade)
  targetUser User @relation("TaggingRequestTarget", fields: [targetUserId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@index([senderId])
  @@index([targetUserId])
  @@index([sectionId])
  @@index([status])
}

model TeamMemberRequest {
  id        String        @id @default(cuid())
  eventId   String // Event ID from Neo4j (stored as string reference)
  senderId  String // User requesting to be a team member
  status    RequestStatus @default(PENDING)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  sender User @relation("TeamMemberRequestSender", fields: [senderId], references: [id], onDelete: Cascade)
  // Note: eventId references Neo4j event, not PostgreSQL Event model

  @@index([eventId])
  @@index([senderId])
  @@index([status])
}

model AuthLevelChangeRequest {
  id             String        @id @default(cuid())
  senderId       String // User requesting the change
  targetUserId   String // User whose auth level should change
  requestedLevel Int // The requested authorization level
  currentLevel   Int // Current authorization level
  message        String // Mandatory explanation message
  status         RequestStatus @default(PENDING)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  sender     User @relation("AuthLevelChangeRequestSender", fields: [senderId], references: [id], onDelete: Cascade)
  targetUser User @relation("AuthLevelChangeRequestTarget", fields: [targetUserId], references: [id], onDelete: Cascade)

  @@index([senderId])
  @@index([targetUserId])
  @@index([status])
}

model RequestApproval {
  id          String   @id @default(cuid())
  requestType String // "TAGGING" | "TEAM_MEMBER" | "GLOBAL_ACCESS" | "AUTH_LEVEL_CHANGE"
  requestId   String // ID of the specific request (polymorphic reference)
  approverId  String // User who approved/denied
  approved    Boolean // true for approval, false for denial
  message     String? // Optional message from approver
  createdAt   DateTime @default(now())

  approver User @relation(fields: [approverId], references: [id], onDelete: Cascade)

  @@index([requestType, requestId])
  @@index([approverId])
}

model Notification {
  id                 String   @id @default(cuid())
  userId             String // User receiving the notification
  type               String // "INCOMING_REQUEST" | "REQUEST_APPROVED" | "REQUEST_DENIED" | "TEAM_MEMBER_ADDED" | etc.
  title              String
  message            String
  relatedRequestType String? // Type of related request
  relatedRequestId   String? // ID of related request
  isOld              Boolean  @default(false)
  createdAt          DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isOld])
  @@index([createdAt])
}

model MagicLinkToken {
  id        String   @id @default(cuid())
  email     String
  userId    String?
  tokenHash String   @unique
  createdAt DateTime @default(now())
  expiresAt DateTime
  usedAt    DateTime?

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([email])
  @@index([expiresAt])
}